P = NP?

A recent paper claims to prove that P is not NP. I wanted to explain the problem so that a bright person with no real technical expertise can understand it. Here goes.

The first idea that I want to establish firmly in your mind is the idea of /decision problems/. This just means any problem which requires you to correctly decide "yes" or "no". An example is, "I have these numbers on a Sudoku grid -- is there a solution?" Well, there's either a bunch of numbers which solve the Sudoku, or there isn't one. The goal is to decide which it is. That's a decision problem.

The next idea that I want to establish is more complicated, and called /polynomial time/. Basically, when you solve a problem, it takes a certain amount of time. The amount of time depends on the problem size: a 4x4 Sudoku is very easy, your regular 9x9 Sudokus take much longer, and a 16x16 Sudoku can probably take days and days. A solution method (an "algorithm") is said to run in "polynomial time" if this is true: when you double the size of the algorithm, then the time to solve the problem is N times as big, for some N. It doesn't matter what N is, but it must be the same no matter how big the problem grows.

For example, sorting a bunch of cards which have numbers written on them. Here is a "slow" solution, which takes much longer than polynomial time: Shuffle the cards and check to see if they're in order. If not, shuffle them again. When you double the size of the problem, the solution will take much much more than twice as long. With 2 cards, you need on average 2 shuffles. With 3, you need on average 6. With 4, you need on average 24. With 5, you need on average 120, and so on. This "factorial function" grows faster than any polynomial. (You may object that technically these all might take /infinite/ time, but it turns out that you can do 3 in /exactly/ 6 permutations, and 4 in /exactly/ 24, and so on.)

Here is a polynomial time solution: search through the cards for the smallest card, and put it first. Search through the cards for the second-smallest, and put it second. And so on. When you double the deck size, you will search twice as often and each search will on average be twice as long, so the total algorithm will take 4 times as long. Here is an even faster polynomial-time solution, which runs in just over 2 times as long: break the deck into 2 halves, sort each half, and then "merge" them together. The merge of the two sorted sub-decks can be done by putting the two side by side, and, in order, taking the smallest card that you can see. Each of these sub-steps takes twice as long, but the merging is usually so much faster than the sorting that you don't notice it in comparison. 

I am now ready to introduce P. P is the set of decision problems which you can solve in polynomial time. It includes problems like "Is this deck sorted?". It (probably) excludes this problem: "Are there an even number of primes smaller than N?" Why? Because if my problem is phrased with N=1000, then the problem which is "twice as big" actually has N = 1000000, twice as many zeroes. Unlike the deck problem, I don't have to tell you N cards, but I only have to tell you log(N) digits. But probably, the only way to tell the exact number of primes is to list them all out and count them.

You see, the /problem/ doesn't have to count to N, but the /solution/ does. In other words, the sort of problem that I'm describing is one which only has a "brute force" solution, which will take you forever to really solve.

Another problem which is pretty much in P is, "is N prime?" -- it turns out that your computer can (with very very high probability) solve this problem for N as big as ~2^4096 or so within a minute or so, even though in decimal that number is something like a 1 followed by 1,233 zeroes. You would not want to try dividing this number by every other number less than it, to figure out whether it is prime or not! But we have mathematical trickery which usually works.

Now, here is another interesting class to think about, called "NP". It is the set of decision problems whose /solutions can be checked/ in polynomial time. For example, solving a 9x9 Sudoku might take me 30 minutes or so. But checking that I haven't broken the rules and that my solution works, while it's a bit tedious, takes less than 1 minute. There are lots of problems like this -- Minesweeper, for example -- which seem to have a simple way to check a solution, but no simple solution. 

Everything in P is in NP. How do I know? Check the solution by using the polynomial-time algorithm to solve the problem for yourself, and check the answer. Done.

But, here is the key question: Is everything in NP also in P? In other words, is there always a way to use the "easy solution-check" to create an "easy solution"? Most professionals believe that the answer is "no" -- that there exist some problems which are hard to solve, but which can be easily checked afterwards. If they are wrong, then the two sets contain the exact same problems and are therefore the same set, so that the question can be phrased very simply: "P = NP?"

But, nobody has yet been able to /prove/ it. It is *very* hard to prove that "nobody can ever do better on this problem than this algorithm" for most problems. All of the obvious examples are like my "count to N" example above, where /checking/ the solution is just as hard as /solving/. But does this always have to hold, or are there hard simple problems? How do we prove that there are limits to our ingenuity? 

An answer to this "P = NP?" question would therefore tell us something absolutely incredible about problems, and would establish fundamental limits on how well we can solve them. That is why this problem is so important -- and worth a million dollars to the Clay Mathematics institute. 

