# Programming for non-programmers

Think of how you might follow a recipe when you cook. The first part of the recipe is really a list of things which the recipe will take for granted. You call them "ingredients", we often call them "primitives." But the primitives almost all come from other recipes -- I mean, it might say "bleached flour", but there is a procedure for milling wheat into flour, and for that matter there is a recipe for buying that flour, which says "go to the store, search the aisles for flour, compare the available ones, buy the most suitable."

In fact, that recipe is more abstract. You don't need to use it to buy flour, you can use it to buy other things. Recipes can have "variables", little bits which we leave unspecified. Those variables might have *types* -- you cannot follow the supermarket-buying-recipe to buy a helicopter -- but that's okay too. I might give you a recipe for how to slice leafy herbs, telling you to roll them up and slice them with a sharp knife. My recipe will work just as well on basil as on mint; "leafy herb" is a typed variable of the recipe. I just need a kitchen robot, let's call it Cookbot, and I just need to tell Cookbot that "mint is a leafy herb, here is how to pick the leaves" and it can slice mint.

We love Cookbot, because they can perform the recipe automatically, and reliably, and quickly. Cookbot can be automatic -- fresh rolls for breakfast every day! But it can also be interactive. Have you ever seen a cooking show where a chef can delegate the boring tasks to their assistants? In many ways Cookbot is like the perfect assistant. If it knows how to do the recipe, it can do that for you, which means you don't need to think about the boring parts. So you might know that chess robots can now beat human chess grandmasters, but the real question is, could the grandmaster start using the chess robot to do even better? How could the chess robot remove the boring parts of chess for a grandmaster, so that they are free to think clearer about very high-level strategy? Could we start playing chess on much bigger chessboards, say 64 x 64 rather than 8 x 8, with computers handling the smaller parts of the game and grandmasters handling the overall fight?

It comes at a cost. Cookbot is absurdly stupid and can only follow the most basic recipes. You specify the bowl, the spoon, the ingredients, and Cookbot dumps those ingredients in the bowl and mixes them with the spoon. Great! But often Cookbot doesn't know when to clean the bowl up, and you have to tell it manually, "clean that bowl up!". Even if you just poured its contents out into a pan which goes in the oven, it might not be able to foresee when the bowl is done with being used. So there's a recipe called 'automatic garbage collection' which looks for dirty bowls around the kitchen which it can *prove* cannot be used anymore. If it can prove that they belonged to a recipe which completed, then it cleans them up. Not all languages use garbage collection by default, because it means that Cookbot usually leaves a lot of dirty bowls around the kitchen, trying to clean them all up at once. And sometimes during a very time-sensitive operation (like cooking a souffl√©), Cookbot will just randomly stop doing the time-sensitive thing and start cleaning up dirty bowls. It's less predictable than telling Cookbot manually, "okay, we're finally done with that bowl, you can wash it now."

But on the other side, sometimes an automatic recipe will have an "edge case", a strange situation which you weren't expecting where you forgot to tell Cookbot to clean up a bowl. Fresh rolls come from the kitchen every day until one day they don't, you walk in and the entire place is filled with dirty mixing bowls, because every once in a while the oven isn't done preheating when the dough is kneaded and ready, and then the dough has to sit in the mixing bowl for longer while the oven finishes preheating, and you forgot to tell Cookbot to clean up the bowl after it puts the rolls on the baking rack when the oven is done preheating. Things like that.

We use recipes for other things than cooking -- a blueprint is really a recipe for a building. You could have blueprints for a factory. Then maybe computers could follow those blueprints and build the factory. You know what's really crazy? Sometimes the factory described by the blueprint is a computer. Sometimes the factory can *build a copy of itself*. Usually the copy is smaller -- similarly, languages implemented in themselves are usually slower -- but that's an abstract technical detail: a factory building a copy of itself is still really cool, even if the copies eventually get too small to be practically useful. It really gives you a sense that such a factory can therefore build anything.
